<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Golang-gorouting-09</title>
      <link href="/2023/03/16/Golang/09goroutine/"/>
      <url>/2023/03/16/Golang/09goroutine/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note primary flat"><div class="note warning flat"><h1 id="协程并发"><a href="#协程并发" class="headerlink" title="协程并发"></a>协程并发</h1><p>协程：coroutine。也叫轻量级线程。</p><p>与传统的系统级线程和进程相比，协程最大的优势在于“轻量级”。可以轻松创建上万个而不会导致系统资源衰竭。而线程和进程通常很难超过 1 万个。这也是协程别称“轻量级线程”的原因。</p><p>一个线程中可以有任意多个协程，但某一时刻只能有一个协程在运行，多个协程分享该线程分配到的计算机资源。</p><p>多数语言在语法层面并不直接支持协程，而是通过库的方式支持，但用库的方式支持的功能也并不完整，比如仅仅提供协程的创建、销毁与切换等能力。如果在这样的轻量级线程中调用一个同步 IO 操作，比如网络通信、本地文件读写，都会阻塞其他的并发执行轻量级线程，从而无法真正达到轻量级线程本身期望达到的目标。</p><pre><code>在协程中，调用一个任务就像调用一个函数一样，消耗的系统资源最少！但能达到进程、线程并发相同的效果。</code></pre><p>在一次并发任务中，进程、线程、协程均可以实现。从系统资源消耗的角度出发来看，进程相当多，线程次之，协程最少。</p></div><h1 id="Go-并发"><a href="#Go-并发" class="headerlink" title="Go 并发"></a>Go 并发</h1><p>Go 在语言级别支持协程，叫 goroutine。Go 语言标准库提供的所有系统调用操作（包括所有同步 IO 操作），都会出让 CPU 给其他 goroutine。这让轻量级线程的切换管理不依赖于系统的线程和进程，也不需要依赖于 CPU 的核心数量。</p><p>有人把 Go 比作 21 世纪的 C 语言。第一是因为 Go 语言设计简单，第二，21 世纪最重要的就是并行程序设计，而 Go 从语言层面就支持并发。同时，并发程序的内存管理有时候是非常复杂的，而 Go 语言提供了自动垃圾回收机制。</p><p>Go 语言为并发编程而内置的上层 API 基于顺序通信进程模型 CSP(communicating sequential processes)。这就意味着显式锁都是可以避免的，因为 Go 通过相对安全的通道发送和接受数据以实现同步，这大大地简化了并发程序的编写。</p><p>Go 语言中的并发程序主要使用两种手段来实现。goroutine 和 channel。</p><h1 id="什么是-Goroutine"><a href="#什么是-Goroutine" class="headerlink" title="什么是 Goroutine"></a>什么是 Goroutine</h1><p>goroutine 是 Go 语言并行设计的核心，有人称之为 go 程。 Goroutine 从量级上看很像协程，它比线程更小，十几个 goroutine 可能体现在底层就是五六个线程，Go 语言内部帮你实现了这些 goroutine 之间的内存共享。执行 goroutine 只需极少的栈内存(大概是 4~5KB)，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。goroutine 比 thread 更易用、更高效、更轻便。</p><p>一般情况下，一个普通计算机跑几十个线程就有点负载过大了，但是同样的机器却可以轻松地让成百上千个 goroutine 进行资源竞争。</p><h1 id="创建-Goroutine"><a href="#创建-Goroutine" class="headerlink" title="创建 Goroutine"></a>创建 Goroutine</h1><p>只需在函数调⽤语句前添加 go 关键字，就可创建并发执⾏单元。开发⼈员无需了解任何执⾏细节，调度器会自动将其安排到合适的系统线程上执行。</p><p>在并发编程中，我们通常想将一个过程切分成几块，然后让每个 goroutine 各自负责一块工作，当一个程序启动时，主函数在一个单独的 goroutine 中运行，我们叫它 main goroutine。新的 goroutine 会用 go 语句来创建。而 go 语言的并发设计，让我们很轻松就可以达成这一目的。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTask</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        i++</span><br><span class="line">        fmt.Printf(<span class="string">&quot;new goroutine: i = %d\n&quot;</span>, i)</span><br><span class="line">        time.Sleep(<span class="number">1</span>*time.Second) <span class="comment">//延时1s</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//创建一个 goroutine，启动另外一个任务</span></span><br><span class="line">    <span class="keyword">go</span> newTask()</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="comment">//main goroutine 循环打印</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        i++</span><br><span class="line">        fmt.Printf(<span class="string">&quot;main goroutine: i = %d\n&quot;</span>, i)</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">//延时1s</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line"><span class="comment">// main gorouting: i = 1</span></span><br><span class="line"><span class="comment">// new gorouting: i = 1</span></span><br><span class="line"><span class="comment">// main gorouting: i = 2</span></span><br><span class="line"><span class="comment">// new gorouting: i = 2</span></span><br><span class="line"><span class="comment">// new gorouting: i = 3</span></span><br><span class="line"><span class="comment">// main gorouting: i = 3</span></span><br><span class="line"><span class="comment">// main gorouting: i = 4</span></span><br><span class="line"><span class="comment">// new gorouting: i = 4</span></span><br></pre></td></tr></table></figure><h1 id="Goroutine-特性"><a href="#Goroutine-特性" class="headerlink" title="Goroutine 特性"></a>Goroutine 特性</h1><p>主 goroutine 退出后，其它的工作 goroutine 也会自动退出：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTask</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        i++</span><br><span class="line">        fmt.Printf(<span class="string">&quot;new goroutine: i = %d\n&quot;</span>, i)</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">//延时1s</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//创建一个 goroutine，启动另外一个任务</span></span><br><span class="line">    <span class="keyword">go</span> newTask()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;main goroutine exit&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码结果：</strong><br><img src="/img/18-goroutine2.png"></p><h1 id="Goexit-函数"><a href="#Goexit-函数" class="headerlink" title="Goexit 函数"></a>Goexit 函数</h1><p>调用 runtime.Goexit() 将立即终止当前 goroutine 执⾏，调度器确保所有已注册 defer 延迟调用被执行。</p><p><strong>示例代码：</strong></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;A.defer&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;B.defer&quot;</span>)</span><br><span class="line">            runtime.Goexit() <span class="comment">// 终止当前 goroutine, import &quot;runtime&quot;</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;B&quot;</span>) <span class="comment">// 不会执行</span></span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        fmt.Println(<span class="string">&quot;A&quot;</span>) <span class="comment">// 不会执行</span></span><br><span class="line">    &#125;()       <span class="comment">//不要忘记()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//死循环，目的不让主goroutine结束</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//代码结果</span></span><br><span class="line">    <span class="comment">// B.defer</span></span><br><span class="line">    <span class="comment">// A.defer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang-反射reflect-08</title>
      <link href="/2023/03/14/Golang/08%E5%8F%8D%E5%B0%84reflect/"/>
      <url>/2023/03/14/Golang/08%E5%8F%8D%E5%B0%84reflect/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note info flat"><h1 id="编程语言中反射的概念"><a href="#编程语言中反射的概念" class="headerlink" title="编程语言中反射的概念"></a>编程语言中反射的概念</h1><p>在计算机科学领域，反射是指一类应用，它们能够自描述和自控制。也就是说，这类应用通过采用某种机制来实现对自己行为的描述（self-representation）和监测（examination），并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。</p><p>每种语言的反射模型都不同，并且有些语言根本不支持反射。Golang 语言实现了反射，反射机制就是在运行时动态的调用对象的方法和属性，官方自带的 reflect 包就是反射相关的，只要包含这个包就可以使用。</p><p>多插一句，Golang 的 gRPC 也是通过反射实现的。</p></div><div class="note primary flat"><h1 id="interface-和-反射"><a href="#interface-和-反射" class="headerlink" title="interface 和 反射"></a>interface 和 反射</h1><p>在讲反射之前，先来看看 Golang 关于类型设计的一些原则</p><p>● 变量包括（type, value）两部分<br>● type 包括 static type 和 concrete type. 简单来说 static type 是你在编码是看见的类型(如 int、string)，concrete type 是 runtime 系统看见的类型<br>● 类型断言能否成功，取决于变量的 concrete type，而不是 static type. 因此，一个 reader 变量如果它的 concrete type 也实现了 write 方法的话，它也可以被类型断言为 writer.</p><p>接下来要讲的反射，就是建立在类型之上的，Golang 的指定类型的变量的类型是静态的（也就是指定 int、string 这些的变量，它的 type 是 static type），在创建变量的时候就已经确定，反射主要与 Golang 的 interface 类型相关（它的 type 是 concrete type），只有 interface 类型才有反射一说。</p><p>在 Golang 的实现中，每个 interface 变量都有一个对应 pair，pair 中记录了实际变量的值和类型:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(value, <span class="keyword">type</span>)</span><br></pre></td></tr></table></figure><p><strong>value 是实际变量值，type 是实际变量的类型。一个 interface{}类型的变量包含了 2 个指针，一个指针指向值的类型【对应 concrete type】，另外一个指针指向实际的值【对应 value】。</strong></p><p>例如，创建类型为*os.File 的变量，然后将其赋给一个接口变量 r：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tty, err := os.OpenFile(<span class="string">&quot;/dev/tty&quot;</span>, os.O_RDWR, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r io.Reader</span><br><span class="line">r = tty</span><br></pre></td></tr></table></figure><p>接口变量 r 的 pair 中将记录如下信息：(tty, *os.File)，这个 pair 在接口变量的连续赋值过程中是不变的，将接口变量 r 赋给另一个接口变量 w:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = r.(io.Writer)</span><br></pre></td></tr></table></figure><p>接口变量 w 的 pair 与 r 的 pair 相同，都是:(tty, *os.File)，即使 w 是空接口类型，pair 也是不变的。</p><p>interface 及其 pair 的存在，是 Golang 中实现反射的前提，理解了 pair，就更容易理解反射。反射就是用来检测存储在接口变量内部(值 value；类型 concrete type) pair 对的一种机制。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">tty, err := os.OpenFile(<span class="string">&quot;/dev/tty&quot;</span>, os.O_RDWR, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;open file error&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r io.Reader</span><br><span class="line">r = tty</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = r.(io.Writer)</span><br><span class="line">w.Write([]<span class="type">byte</span>(<span class="string">&quot;HELLO THIS IS A TEST!!!\n&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><mark class="hl-label pink">再比如:</mark> </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">ReadBook()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">WriteBook()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体类型</span></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Book)</span></span> ReadBook() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Read a book.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Book)</span></span> WriteBook() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Write a book.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">b := &amp;Book&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r Reader</span><br><span class="line">r = b</span><br><span class="line"></span><br><span class="line">r.ReadBook()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w Writer</span><br><span class="line">w = r.(Writer)</span><br><span class="line">w.WriteBook()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="note primary flat"><h1 id="Golang-的反射-reflect"><a href="#Golang-的反射-reflect" class="headerlink" title="Golang 的反射 reflect"></a>Golang 的反射 reflect</h1><div class="note info flat"><h2 id="reflect-的基本功能-TypeOf-和-ValueOf"><a href="#reflect-的基本功能-TypeOf-和-ValueOf" class="headerlink" title="reflect 的基本功能 TypeOf 和 ValueOf"></a>reflect 的基本功能 TypeOf 和 ValueOf</h2><p>既然反射就是用来检测存储在接口变量内部(值 value；类型 concrete type) pair 对的一种机制。那么在 Golang 的 reflect 反射包中有什么样的方式可以让我们直接获取到变量内部的信息呢？ 它提供了两种类型（或者说两个方法）让我们可以很容易的访问接口变量内容，分别是 reflect.ValueOf() 和 reflect.TypeOf()，看看官方的解释</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ValueOf returns a new Value initialized to the concrete value</span></span><br><span class="line"><span class="comment">// stored in the interface i.  ValueOf(nil) returns the zero</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ValueOf用来获取输入参数接口中的数据的值，如果接口为空则返回0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeOf returns the reflection Type that represents the dynamic type of i.</span></span><br><span class="line"><span class="comment">// If i is a nil interface value, TypeOf returns nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Type &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TypeOf用来动态获取输入参数接口中的值的类型，如果接口为空则返回nil</span></span><br></pre></td></tr></table></figure><p><strong>reflect.TypeOf()是获取 pair 中的 type，reflect.ValueOf()获取 pair 中的 value，示例如下：</strong></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num <span class="type">float64</span> = <span class="number">1.2345</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;type: &quot;</span>, reflect.TypeOf(num))</span><br><span class="line">    fmt.Println(<span class="string">&quot;value: &quot;</span>, reflect.ValueOf(num))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果:</span><br><span class="line"><span class="keyword">type</span>:  <span class="type">float64</span></span><br><span class="line">value:  <span class="number">1.2345</span></span><br></pre></td></tr></table></figure><p><mark class="hl-label pink">说明</mark> </p><ol><li>reflect.TypeOf： 直接给到了我们想要的 type 类型，如 float64、int、各种 pointer、struct 等等真实的类型</li><li>reflect.ValueOf：直接给到了我们想要的具体的值，如 1.2345 这个具体数值，或者类似&amp;{1 “Allen.Wu” 25} 这样的结构体 struct 的值</li><li>也就是说明反射可以将“接口类型变量”转换为“反射类型对象”，反射类型指的是 reflect.Type 和 reflect.Value 这两种</li></ol><p><strong>通过运行结果可以得知获取未知类型的 interface 的所属方法（函数）的步骤为：</strong></p><ol><li>先获取 interface 的 reflect.Type，然后通过 NumMethod 进行遍历</li><li>再分别通过 reflect.Type 的 Method 获取对应的真实的方法（函数）</li><li>最后对结果取其 Name 和 Type 得知具体的方法名</li><li>也就是说反射可以将“反射类型对象”再重新转换为“接口类型变量”</li><li>struct 或者 struct 的嵌套都是一样的判断处理方式</li></ol></div><div class="note info flat"><h2 id="通过-reflect-Value-设置实际变量的值"><a href="#通过-reflect-Value-设置实际变量的值" class="headerlink" title="通过 reflect.Value 设置实际变量的值"></a>通过 reflect.Value 设置实际变量的值</h2><p>reflect.Value 是通过 reflect.ValueOf(X)获得的，只有当 X 是指针的时候，才可以通过 reflec.Value 修改实际变量 X 的值，即：要修改反射类型的对象就一定要保证其值是“addressable”的。</p><p><strong>示例如下：</strong></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> num <span class="type">float64</span> = <span class="number">1.2345</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;old value of pointer:&quot;</span>, num)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过reflect.ValueOf获取num中的reflect.Value，注意，参数必须是指针才能修改其值</span></span><br><span class="line">    pointer := reflect.ValueOf(&amp;num)</span><br><span class="line">    newValue := pointer.Elem()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;type of pointer:&quot;</span>, newValue.Type())</span><br><span class="line">    fmt.Println(<span class="string">&quot;settability of pointer:&quot;</span>, newValue.CanSet())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新赋值</span></span><br><span class="line">    newValue.SetFloat(<span class="number">77</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;new value of pointer:&quot;</span>, num)</span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////</span></span><br><span class="line">    <span class="comment">// 如果reflect.ValueOf的参数不是指针，会如何？</span></span><br><span class="line">    pointer = reflect.ValueOf(num)</span><br><span class="line">    <span class="comment">//newValue = pointer.Elem() // 如果非指针，这里直接panic，“panic: reflect: call of reflect.Value.Elem on float64 Value”</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// old value of pointer: 1.2345</span></span><br><span class="line"><span class="comment">// type of pointer: float64</span></span><br><span class="line"><span class="comment">// settability of pointer: true</span></span><br><span class="line"><span class="comment">// new value of pointer: 77</span></span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><ol><li>需要传入的参数是* float64 这个指针，然后可以通过 pointer.Elem()去获取所指向的 Value，注意一定要是指针。</li><li>如果传入的参数不是指针，而是变量，那么<ul><li>通过 Elem 获取原始值对应的对象则直接 panic</li><li>通过 CanSet 方法查询是否可以设置返回 false</li></ul></li><li>newValue.CantSet()表示是否可以重新设置其值，如果输出的是 true 则可修改，否则不能修改，修改完之后再进行打印发现真的已经修改了。</li><li>reflect.Value.Elem() 表示获取原始值对应的反射对象，只有原始对象才能修改，当前反射对象是不能修改的</li><li>也就是说如果要修改反射类型对象，其值必须是“addressable”【对应的要传入的是指针，同时要通过 Elem 方法获取原始值对应的反射对象】</li><li>struct 或者 struct 的嵌套都是一样的判断处理方式</li></ol></div><div class="note info flat"><h2 id="通过-reflect-ValueOf-来进行方法的调用"><a href="#通过-reflect-ValueOf-来进行方法的调用" class="headerlink" title="通过 reflect.ValueOf 来进行方法的调用"></a>通过 reflect.ValueOf 来进行方法的调用</h2><p>这算是一个高级用法了，前面我们只说到对类型、变量的几种反射的用法，包括如何获取其值、其类型、如果重新设置新值。但是在工程应用中，另外一个常用并且属于高级的用法，就是通过 reflect 来进行方法【函数】的调用。比如我们要做框架工程的时候，需要可以随意扩展方法，或者说用户可以自定义方法，那么我们通过什么手段来扩展让用户能够自定义呢？关键点在于用户的自定义方法是未可知的，因此我们可以通过 reflect 来搞定</p><p><strong>示例如下：</strong></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id   <span class="type">int</span></span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span></span> ReflectCallFuncHasArgs(name <span class="type">string</span>, age <span class="type">int</span>) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;ReflectCallFuncHasArgs name: &quot;</span>, name, <span class="string">&quot;, age:&quot;</span>, age, <span class="string">&quot;and origal User.Name:&quot;</span>, u.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span></span> ReflectCallFuncNoArgs() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;ReflectCallFuncNoArgs&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如何通过反射来进行方法的调用？</span></span><br><span class="line"><span class="comment">// 本来可以用u.ReflectCallFuncXXX直接调用的，但是如果要通过反射，那么首先要将方法注册，也就是MethodByName，然后通过反射调动mv.Call</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    user := User&#123;<span class="number">1</span>, <span class="string">&quot;Allen.Wu&quot;</span>, <span class="number">25</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 要通过反射来调用起对应的方法，必须要先通过reflect.ValueOf(interface)来获取到reflect.Value，得到“反射类型对象”后才能做下一步处理</span></span><br><span class="line">    getValue := reflect.ValueOf(user)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一定要指定参数为正确的方法名</span></span><br><span class="line">    <span class="comment">// 2. 先看看带有参数的调用方法</span></span><br><span class="line">    methodValue := getValue.MethodByName(<span class="string">&quot;ReflectCallFuncHasArgs&quot;</span>)</span><br><span class="line">    args := []reflect.Value&#123;reflect.ValueOf(<span class="string">&quot;wudebao&quot;</span>), reflect.ValueOf(<span class="number">30</span>)&#125;</span><br><span class="line">    methodValue.Call(args)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一定要指定参数为正确的方法名</span></span><br><span class="line">    <span class="comment">// 3. 再看看无参数的调用方法</span></span><br><span class="line">    methodValue = getValue.MethodByName(<span class="string">&quot;ReflectCallFuncNoArgs&quot;</span>)</span><br><span class="line">    args = <span class="built_in">make</span>([]reflect.Value, <span class="number">0</span>)</span><br><span class="line">    methodValue.Call(args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// ReflectCallFuncHasArgs name:  wudebao , age: 30 and origal User.Name: Allen.Wu</span></span><br><span class="line"><span class="comment">// ReflectCallFuncNoArgs</span></span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><ol><li>要通过反射来调用起对应的方法，必须要先通过 reflect.ValueOf(interface)来获取到 reflect.Value，得到“反射类型对象”后才能做下一步处理</li><li>reflect.Value.MethodByName 这.MethodByName，需要指定准确真实的方法名字，如果错误将直接 panic，MethodByName 返回一个函数值对应的 reflect.Value 方法的名字。</li><li>[]reflect.Value，这个是最终需要调用的方法的参数，可以没有或者一个或者多个，根据实际参数来定。</li><li>reflect.Value 的 Call 这个方法，这个方法将最终调用真实的方法，参数务必保持一致，如果 reflect.Value’Kind 不是一个方法，那么将直接 panic。</li><li>本来可以用 u.ReflectCallFuncXXX 直接调用的，但是如果要通过反射，那么首先要将方法注册，也就是 MethodByName，然后通过反射调用 methodValue.Call</li></ol></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上述详细说明了 Golang 的反射 reflect 的各种功能和用法，都附带有相应的示例，相信能够在工程应用中进行相应实践，总结一下就是：</p><ol><li>反射可以大大提高程序的灵活性，使得 interface{}有更大的发挥余地</li></ol><ul><li>反射必须结合 interface 才玩得转</li><li>变量的 type 要是 concrete type 的（也就是 interface 变量）才有反射一说</li></ul><ol start="2"><li>反射可以将“接口类型变量”转换为“反射类型对象”</li></ol><ul><li>反射使用 TypeOf 和 ValueOf 函数从接口中获取目标对象信息</li></ul><ol start="3"><li>反射可以将“反射类型对象”转换为“接口类型变量</li></ol><ul><li>reflect.value.Interface().(已知的类型)</li><li>遍历 reflect.Type 的 Field 获取其 Field</li></ul><ol start="4"><li>反射可以修改反射类型对象，但是其值必须是“addressable”</li></ol><ul><li>想要利用反射修改对象状态，前提是 interface.data 是 settable,即 pointer-interface</li></ul><ol start="5"><li>通过反射可以“动态”调用方法</li><li>因为 Golang 本身不支持模板，因此在以往需要使用模板的场景下往往就需要使用反射(reflect)来实现</li></ol><h1 id="反射的基本原理"><a href="#反射的基本原理" class="headerlink" title="反射的基本原理"></a>反射的基本原理</h1><p><img src="/img/16-%E5%8F%8D%E5%B0%841.png"></p></div>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang-interface与类型断言-07</title>
      <link href="/2023/03/14/Golang/07interface%E4%B8%8E%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/"/>
      <url>/2023/03/14/Golang/07interface%E4%B8%8E%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note primary flat"><p><strong>Golang 的语言中提供了断言的功能。golang 中的所有程序都实现了 interface{}的接口，这意味着，所有的类型如 string,int,int64 甚至是自定义的 struct 类型都就此拥有了 interface{}的接口，这种做法和 java 中的 Object 类型比较类似。那么在一个数据通过 func funcName(interface{})的方式传进来的时候，也就意味着这个参数被自动的转为 interface{}的类型。</strong></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="type">string</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><mark class="hl-label pink">编译器会返回</mark> </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot convert a (<span class="keyword">type</span> <span class="keyword">interface</span>&#123;&#125;) to <span class="keyword">type</span> <span class="type">string</span>: need <span class="keyword">type</span> assertion</span><br></pre></td></tr></table></figure><p>此时，意味着整个转化的过程需要类型断言。类型断言有以下几种形式：</p><div class="note info flat"><h2 id="1-直接断言使用"><a href="#1-直接断言使用" class="headerlink" title="(1) 直接断言使用"></a>(1) 直接断言使用</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Where are you,Jonny?&quot;</span>, a.(<span class="type">string</span>))</span><br></pre></td></tr></table></figure><p>但是如果断言失败一般会导致 panic 的发生。所以为了防止 panic 的发生，我们需要在断言前进行一定的判断</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value, ok := a.(<span class="type">string</span>)</span><br></pre></td></tr></table></figure><p>如果断言失败，那么 ok 的值将会是 false,但是如果断言成功 ok 的值将会是 true,同时 value 将会得到所期待的正确的值。示例：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">value, ok := a.(<span class="type">string</span>)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;It&#x27;s not ok for type string&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;The value is &quot;</span>, value)</span><br></pre></td></tr></table></figure><p><strong>完整例子如下：</strong></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">func funcName(a interface&#123;&#125;) string &#123;</span></span><br><span class="line"><span class="comment">        return string(a)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">        value, ok := a.(<span class="type">string</span>)</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;It is not ok for type string&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">&quot;The value is &quot;</span>, value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//      str := &quot;123&quot;</span></span><br><span class="line">        <span class="comment">//      funcName(str)</span></span><br><span class="line">        <span class="comment">//var a interface&#123;&#125;</span></span><br><span class="line">        <span class="comment">//var a string = &quot;123&quot;</span></span><br><span class="line">        <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">        funcName(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="note info flat"><h2 id="2-配合-switch-使用"><a href="#2-配合-switch-使用" class="headerlink" title="(2) 配合 switch 使用"></a>(2) 配合 switch 使用</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">t = functionOfSomeType()</span><br><span class="line"><span class="keyword">switch</span> t := t.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;unexpected type %T&quot;</span>, t)       <span class="comment">// %T prints whatever type t has</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;boolean %t\n&quot;</span>, t)             <span class="comment">// t has type bool</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;integer %d\n&quot;</span>, t)             <span class="comment">// t has type int</span></span><br><span class="line"><span class="keyword">case</span> *<span class="type">bool</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;pointer to boolean %t\n&quot;</span>, *t) <span class="comment">// t has type *bool</span></span><br><span class="line"><span class="keyword">case</span> *<span class="type">int</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;pointer to integer %d\n&quot;</span>, *t) <span class="comment">// t has type *int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者如下使用方法</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqlQuote</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;NULL&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> _, ok := x.(<span class="type">int</span>); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, x)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> _, ok := x.(<span class="type">uint</span>); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, x)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> b, ok := x.(<span class="type">bool</span>); ok &#123;</span><br><span class="line">        <span class="keyword">if</span> b &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;TRUE&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;FALSE&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> s, ok := x.(<span class="type">string</span>); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> sqlQuoteString(s) <span class="comment">// (not shown)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;unexpected type %T: %v&quot;</span>, x, x))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang-slice和map-06</title>
      <link href="/2023/03/13/Golang/06slice%E5%92%8Cmap/"/>
      <url>/2023/03/13/Golang/06slice%E5%92%8Cmap/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note info flat"><h1 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h1><p><strong>Go 语言 切片是对数组的抽象</strong></p><p>Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go 中提供了一种灵活，功能强悍的内置类型切片(&#x3D;&#x3D;”动态数组”&#x3D;&#x3D;)，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。</p><h2 id="定义切片"><a href="#定义切片" class="headerlink" title="定义切片"></a>定义切片</h2><p>你可以声明一个未指定大小的数组来定义切片：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier []<span class="keyword">type</span></span><br></pre></td></tr></table></figure><p>切片不需要说明长度。<br>或使用 make()函数来创建切片:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 []<span class="keyword">type</span> = <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">也可以简写为</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">slice1 := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br></pre></td></tr></table></figure><p>也可以指定容量，其中 capacity 为可选参数。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, length, capacity)</span><br></pre></td></tr></table></figure><p>这里 len 是数组的长度并且也是切片的初始长度。</p><h2 id="切片初始化"><a href="#切片初始化" class="headerlink" title="切片初始化"></a>切片初始化</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s :=[] <span class="type">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;</span><br><span class="line"><span class="comment">//直接初始化切片，[]表示是切片类型，&#123;1,2,3&#125;初始化值依次是1,2,3.其cap=len=3</span></span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s := arr[:]</span><br><span class="line"><span class="comment">//初始化切片s,是数组arr的引用</span></span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s := arr[startIndex:endIndex]</span><br><span class="line"><span class="comment">//将arr中从下标startIndex到endIndex-1 下的元素创建为一个新的切片</span></span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s := arr[startIndex:]</span><br><span class="line"><span class="comment">//缺省endIndex时将表示一直到arr的最后一个元素</span></span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s := arr[:endIndex]</span><br><span class="line"><span class="comment">//缺省startIndex时将表示从arr的第一个元素开始</span></span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 := s[startIndex:endIndex]</span><br><span class="line"><span class="comment">//通过切片s初始化切片s1</span></span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s :=<span class="built_in">make</span>([]<span class="type">int</span>,<span class="built_in">len</span>,<span class="built_in">cap</span>)</span><br><span class="line"><span class="comment">//通过内置函数make()初始化切片s,[]int 标识为其元素类型为int的切片</span></span><br></pre></td></tr></table></figure><h2 id="len-和-cap-函数"><a href="#len-和-cap-函数" class="headerlink" title="len() 和 cap() 函数"></a>len() 和 cap() 函数</h2><p>切片是可索引的，并且可以由 len() 方法获取长度。<br>切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。<br>以下为具体实例：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers = <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   printSlice(numbers)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码结果</span></span><br><span class="line"><span class="comment">//len=3 cap=5 slice=[0 0 0]</span></span><br></pre></td></tr></table></figure><h2 id="空-nil-切片"><a href="#空-nil-切片" class="headerlink" title="空(nil)切片"></a>空(nil)切片</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(numbers == <span class="literal">nil</span>)&#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;切片是空的&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代码结果</span></span><br><span class="line"><span class="comment">// len=0 cap=0 slice=[]</span></span><br><span class="line"><span class="comment">// 切片是空的</span></span><br></pre></td></tr></table></figure><h2 id="切片截取"><a href="#切片截取" class="headerlink" title="切片截取"></a>切片截取</h2><p>可以通过设置下限及上限来设置截取切片 [lower-bound:upper-bound]，实例如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 创建切片 */</span></span><br><span class="line">   numbers := []<span class="type">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印原始切片 */</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers ==&quot;</span>, numbers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引1(包含) 到索引4(不包含)*/</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers[1:4] ==&quot;</span>, numbers[<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 默认下限为 0*/</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers[:3] ==&quot;</span>, numbers[:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 默认上限为 len(s)*/</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers[4:] ==&quot;</span>, numbers[<span class="number">4</span>:])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   numbers1 := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line">   printSlice(numbers1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引  0(包含) 到索引 2(不包含) */</span></span><br><span class="line">   number2 := numbers[:<span class="number">2</span>]</span><br><span class="line">   printSlice(number2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引 2(包含) 到索引 5(不包含) */</span></span><br><span class="line">   number3 := numbers[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">   printSlice(number3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代码结果</span></span><br><span class="line"><span class="comment">// len=9 cap=9 slice=[0 1 2 3 4 5 6 7 8]</span></span><br><span class="line"><span class="comment">// numbers == [0 1 2 3 4 5 6 7 8]</span></span><br><span class="line"><span class="comment">// numbers[1:4] == [1 2 3]</span></span><br><span class="line"><span class="comment">// numbers[:3] == [0 1 2]</span></span><br><span class="line"><span class="comment">// numbers[4:] == [4 5 6 7 8]</span></span><br><span class="line"><span class="comment">// len=0 cap=5 slice=[]</span></span><br><span class="line"><span class="comment">// len=2 cap=9 slice=[0 1]</span></span><br><span class="line"><span class="comment">// len=3 cap=7 slice=[2 3 4]</span></span><br></pre></td></tr></table></figure><h2 id="append-和-copy-函数"><a href="#append-和-copy-函数" class="headerlink" title="append() 和 copy() 函数"></a>append() 和 copy() 函数</h2><p>如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。<br>下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers []<span class="type">int</span></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 允许追加空切片 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">0</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 向切片添加一个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">1</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 同时添加多个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 创建切片 numbers1 是之前切片的两倍容量*/</span></span><br><span class="line">   numbers1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(numbers), (<span class="built_in">cap</span>(numbers))*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 拷贝 numbers 的内容到 numbers1 */</span></span><br><span class="line">   <span class="built_in">copy</span>(numbers1,numbers)</span><br><span class="line">   printSlice(numbers1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代码结果</span></span><br><span class="line"><span class="comment">// len=0 cap=0 slice=[]</span></span><br><span class="line"><span class="comment">// len=1 cap=1 slice=[0]</span></span><br><span class="line"><span class="comment">// len=2 cap=2 slice=[0 1]</span></span><br><span class="line"><span class="comment">// len=5 cap=6 slice=[0 1 2 3 4]</span></span><br><span class="line"><span class="comment">// len=5 cap=12 slice=[0 1 2 3 4]</span></span><br></pre></td></tr></table></figure></div><div class="note default flat"><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>map 和 slice 类似，只不过是数据结构不同，下面是 map 的一些声明方式。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//第一种声明</span></span><br><span class="line">    <span class="keyword">var</span> test1 <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">    <span class="comment">//在使用map前，需要先make，make的作用就是给map分配数据空间</span></span><br><span class="line">    test1 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">10</span>)</span><br><span class="line">    test1[<span class="string">&quot;one&quot;</span>] = <span class="string">&quot;php&quot;</span></span><br><span class="line">    test1[<span class="string">&quot;two&quot;</span>] = <span class="string">&quot;golang&quot;</span></span><br><span class="line">    test1[<span class="string">&quot;three&quot;</span>] = <span class="string">&quot;java&quot;</span></span><br><span class="line">    fmt.Println(test1) <span class="comment">//map[two:golang three:java one:php]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种声明</span></span><br><span class="line">    test2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">    test2[<span class="string">&quot;one&quot;</span>] = <span class="string">&quot;php&quot;</span></span><br><span class="line">    test2[<span class="string">&quot;two&quot;</span>] = <span class="string">&quot;golang&quot;</span></span><br><span class="line">    test2[<span class="string">&quot;three&quot;</span>] = <span class="string">&quot;java&quot;</span></span><br><span class="line">    fmt.Println(test2) <span class="comment">//map[one:php two:golang three:java]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三种声明</span></span><br><span class="line">    test3 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">        <span class="string">&quot;one&quot;</span> : <span class="string">&quot;php&quot;</span>,</span><br><span class="line">        <span class="string">&quot;two&quot;</span> : <span class="string">&quot;golang&quot;</span>,</span><br><span class="line">        <span class="string">&quot;three&quot;</span> : <span class="string">&quot;java&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(test3) <span class="comment">//map[one:php two:golang three:java]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    language := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">    language[<span class="string">&quot;php&quot;</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">2</span>)</span><br><span class="line">    language[<span class="string">&quot;php&quot;</span>][<span class="string">&quot;id&quot;</span>] = <span class="string">&quot;1&quot;</span></span><br><span class="line">    language[<span class="string">&quot;php&quot;</span>][<span class="string">&quot;desc&quot;</span>] = <span class="string">&quot;php是世界上最美的语言&quot;</span></span><br><span class="line">    language[<span class="string">&quot;golang&quot;</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">2</span>)</span><br><span class="line">    language[<span class="string">&quot;golang&quot;</span>][<span class="string">&quot;id&quot;</span>] = <span class="string">&quot;2&quot;</span></span><br><span class="line">    language[<span class="string">&quot;golang&quot;</span>][<span class="string">&quot;desc&quot;</span>] = <span class="string">&quot;golang抗并发非常good&quot;</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(language) <span class="comment">//map[php:map[id:1 desc:php是世界上最美的语言] golang:map[id:2 desc:golang抗并发非常good]]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//增删改查</span></span><br><span class="line">    <span class="comment">// val, key := language[&quot;php&quot;]  //查找是否有php这个子元素</span></span><br><span class="line">    <span class="comment">// if key &#123;</span></span><br><span class="line">    <span class="comment">//     fmt.Printf(&quot;%v&quot;, val)</span></span><br><span class="line">    <span class="comment">// &#125; else &#123;</span></span><br><span class="line">    <span class="comment">//     fmt.Printf(&quot;no&quot;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//language[&quot;php&quot;][&quot;id&quot;] = &quot;3&quot; //修改了php子元素的id值</span></span><br><span class="line">    <span class="comment">//language[&quot;php&quot;][&quot;nickname&quot;] = &quot;啪啪啪&quot; //增加php元素里的nickname值</span></span><br><span class="line">    <span class="comment">//delete(language, &quot;php&quot;)  //删除了php子元素</span></span><br><span class="line">    fmt.Println(language)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack优化手段</title>
      <link href="/2023/03/12/Webpack/"/>
      <url>/2023/03/12/Webpack/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note primary flat"><div class="note info flat"><h1 id="构建时间优化"><a href="#构建时间优化" class="headerlink" title="构建时间优化"></a>构建时间优化</h1><p><strong>首先就是构建时间的优化了</strong></p><h2 id="1-thread-loader"><a href="#1-thread-loader" class="headerlink" title="(1) thread-loader"></a>(1) thread-loader</h2><p>多进程打包，可以大大提高构建的速度，使用方法是将 thread-loader 放在比较费时间的 loader 之前，比如 babel-loader</p><p>由于启动项目和打包项目都需要加速，所以配置在 webpack.base.js</p><figure class="highlight javascript"><figcaption><span>npm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i thread-loader -D</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.base.js</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    <span class="attr">use</span>: [</span><br><span class="line">        <span class="string">&#x27;thread-loader&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;babel-loader&#x27;</span></span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="note info flat"><h2 id="2-cache-loader"><a href="#2-cache-loader" class="headerlink" title="(2) cache-loader"></a>(2) cache-loader</h2><p>缓存资源，提高二次构建的速度，使用方法是将 cache-loader 放在比较费时间的 loader 之前，比如 babel-loader</p><p>由于启动项目和打包项目都需要加速，所以配置在 webpack.base.js</p><figure class="highlight javascript"><figcaption><span>npm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i cache-loader -D</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.base.js</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    <span class="attr">use</span>: [</span><br><span class="line">        <span class="string">&#x27;cache-loader&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;thread-loader&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;babel-loader&#x27;</span></span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="note info flat"><h2 id="3-开启热更新"><a href="#3-开启热更新" class="headerlink" title="(3) 开启热更新"></a>(3) 开启热更新</h2><p>比如你修改了项目中某一个文件，会导致整个项目刷新，这非常耗时间。如果只刷新修改的这个模块，其他保持原状，那将大大提高修改代码的重新构建时间</p><p>只用于开发中，所以配置在 webpack.dev.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.dev.js</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//引入webpack</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="comment">//使用webpack提供的热更新插件</span></span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">     <span class="keyword">new</span> webpack.<span class="title class_">HotModuleReplacementPlugin</span>()</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后在我们的devServer中配置</span></span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">     <span class="attr">hot</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><div class="note info flat"><h2 id="4-exclude-amp-include"><a href="#4-exclude-amp-include" class="headerlink" title="(4) exclude &amp; include"></a>(4) exclude &amp; include</h2><p>exclude: 不需要处理的文件<br>include: 需要处理的文件<br>合理设置这两个属性，可以大大提高构建速度</p><p>在 webpack.base.js 中配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.base.js</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    <span class="comment">//使用include来指定编译文件夹</span></span><br><span class="line">    <span class="attr">include</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../src&#x27;</span>)</span><br><span class="line">    <span class="comment">//使用exclude排除指定文件夹</span></span><br><span class="line">    <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    <span class="attr">use</span>: [</span><br><span class="line">        <span class="string">&#x27;balel-loader&#x27;</span></span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="note info flat"><h2 id="5-构建区分环境"><a href="#5-构建区分环境" class="headerlink" title="(5) 构建区分环境"></a>(5) 构建区分环境</h2><p>区分环境去构建是非常重要的，我们要明确知道，开发环境时我们需要哪些配置，不需要哪些配置；而最终打包生产环境时又需要哪些配置，不需要那些配置：</p><ul><li>开发环境：去除代码压缩、gzip、体积分析等优化的配置，大大提高构建速度</li><li>生产环境：需要代码压缩、gzip、体积分析等优化的配置，大大降低最终项目打包体积</li></ul><p>在 webpack.base.js 中配置</p></div><div class="note info flat"><h2 id="6-提升-webpack-版本"><a href="#6-提升-webpack-版本" class="headerlink" title="(6) 提升 webpack 版本"></a>(6) 提升 webpack 版本</h2><p>webpack 版本越新，打包的效果肯定更好</p></div><div class="note success flat"><h1 id="打包体积优化"><a href="#打包体积优化" class="headerlink" title="打包体积优化"></a>打包体积优化</h1><p><strong>主要是打包后项目整体体积的优化，有利于项目上线后的页面加载速度提升</strong></p><h2 id="1-CSS-代码压缩"><a href="#1-CSS-代码压缩" class="headerlink" title="(1) CSS 代码压缩"></a>(1) CSS 代码压缩</h2><p>CSS 代码压缩使用 css-minimizer-webpack-plugin，效果包括压缩、去重。<br>代码的压缩比较耗时间，所以只用在打包项目时，所以只需要在 webpack.prod.js 中配置</p><figure class="highlight javascript"><figcaption><span>npm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i css-minimizer-webpack-plugin -D</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.prod.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CssMinimizerPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;css-minimizer&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line">        <span class="attr">minimizer</span>: [</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CssMinimizerPlugin</span>() <span class="comment">//去重压缩CSS</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><div class="note success flat"><h2 id="2-JS-代码压缩"><a href="#2-JS-代码压缩" class="headerlink" title="(2) JS 代码压缩"></a>(2) JS 代码压缩</h2><p>JS 代码压缩使用 terser-webpack-plugin，实现打包后 JS 代码的压缩<br>代码的压缩比较耗时间，所以只用在打包项目时，所以只需要在 webpack.prod.js 中配置</p><figure class="highlight javascript"><figcaption><span>npm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i terser-webpack-plugin -D</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.prod.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TerserPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;terser-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line">        <span class="attr">minimizer</span>: [</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CssMinimizerPlugin</span>(), <span class="comment">//去重压缩CSS</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">TerserPlugin</span>(&#123;</span><br><span class="line">                <span class="attr">terserOptions</span>: &#123;</span><br><span class="line">                    <span class="attr">compress</span>: &#123;</span><br><span class="line">                        <span class="attr">drop_console</span>: <span class="literal">true</span>, <span class="comment">//去除console</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;), <span class="comment">// 压缩JavaScript</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><div class="note success flat"><h2 id="3-tree-shaking"><a href="#3-tree-shaking" class="headerlink" title="(3) tree-shaking"></a>(3) tree-shaking</h2><p>tree-shaking 简单来说作用就是：只打包用到的代码，没用到的代码不打包，而 webpack5 默认开启 tree-shaking，当打包的 mode 为 production 时，自动开启 tree-shaking 进行优化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.dev.js</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="note success flat"><h2 id="4-source-map-类型"><a href="#4-source-map-类型" class="headerlink" title="(4) source-map 类型"></a>(4) source-map 类型</h2><p>source-map 的作用是：方便你报错的时候能定位到错误代码的位置。它的体积不容小觑，所以对于不同环境设置不同的类型是很有必要的</p><ul><li><strong>开发环境</strong><br>开发环境的时候我们需要能精准定位错误代码的位置</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.dev.js</span></span><br><span class="line"></span><br><span class="line">   <span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">       <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">       <span class="attr">devtool</span>: <span class="string">&#x27;eval-cheap-module-source-map&#x27;</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>生产环境</strong><br>生产环境的时候，我们想开启 source-map，但是又不想体积太大，那么可以换一种类型</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.dev.js</span></span><br><span class="line"></span><br><span class="line">   <span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">       <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">       <span class="attr">devtool</span>: <span class="string">&#x27;nosources-source-map&#x27;</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><div class="note success flat"><h2 id="5-打包体积分析"><a href="#5-打包体积分析" class="headerlink" title="(5) 打包体积分析"></a>(5) 打包体积分析</h2><p>使用 webpack-bundle-analyzer 可以审查打包后的体积分布，进而进行相应的体积优化<br>只需要打包时看体积，所以只需在 webpack.prod.js 中配置</p><figure class="highlight javascript"><figcaption><span>npm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack-bundle-analyzer -D</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.dev.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">BundleAnalyzerPlugin</span> &#125; = requireol(<span class="string">&#x27;webpack-bundle-analyzer&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">BundleAnalyzerPlugin</span>(),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div><div class="note danger flat"><h1 id="用户体验优化"><a href="#用户体验优化" class="headerlink" title="用户体验优化"></a>用户体验优化</h1><h2 id="1-模块懒加载"><a href="#1-模块懒加载" class="headerlink" title="(1) 模块懒加载"></a>(1) 模块懒加载</h2><p>如果不进行懒加载的话，最后整个项目代码都会被打包到一个 js 文件里，单个 js 文件体积非常大，那么当用户网页请求的时候，首屏加载时间会比较长，使用模块懒加载之后，大 js 文件会分成多个小 js 文件，网页加载时会按需加载，大大提升首屏加载速度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/router/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;login&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: login</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;login&#x27;</span>,</span><br><span class="line">        <span class="comment">//懒加载</span></span><br><span class="line">        <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/home/home&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div><div class="note danger flat"><h2 id="2-Gzip"><a href="#2-Gzip" class="headerlink" title="(2) Gzip"></a>(2) Gzip</h2><p>开启 Gzip 后，大大提高用户的页面加载速度，因为 gzip 的体积比原文件小很多，当然需要后端的配合，使用 compression-webpack-plugin 只需要打包时优化体积，所以只需在 webpack.prod.js 中配置</p><figure class="highlight javascript"><figcaption><span>npm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i compression-webpack-plugin -D</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.prod.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CompressionPlugin</span> = requireol(<span class="string">&#x27;compression-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">//之前的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//gzip</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CompressionPlugin</span>(&#123;</span><br><span class="line">        <span class="attr">algorithm</span>: <span class="string">&#x27;gzip&#x27;</span>,</span><br><span class="line">        <span class="attr">threshold</span>: <span class="number">10240</span>,</span><br><span class="line">        <span class="attr">minRatio</span>: <span class="number">0.8</span></span><br><span class="line">    &#125;),</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><div class="note danger flat"><h2 id="3-小图片转-base64"><a href="#3-小图片转-base64" class="headerlink" title="(3) 小图片转 base64"></a>(3) 小图片转 base64</h2><p>对于一些小图片，可以转 base64，这样可以减少用户的 http 网络请求次数，提高用户的体验。webpack5 中 url-loader 已被废弃，改用 asset-module<br>在 webpack.base.js 中配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.base.js</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|svg|webg)$/</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;asset&#x27;</span>,</span><br><span class="line">    <span class="attr">perser</span>: &#123;</span><br><span class="line">        <span class="comment">//转base64的条件</span></span><br><span class="line">        <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">            <span class="attr">maxSize</span>: <span class="number">25</span> * <span class="number">1024</span>, <span class="comment">//25kb</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">generator</span>: &#123;</span><br><span class="line">        <span class="comment">//打包到 image 文件下</span></span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;images/[contenthash][ext][query]&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><div class="note danger flat"><h2 id="4-合理配置-hash"><a href="#4-合理配置-hash" class="headerlink" title="(4) 合理配置 hash"></a>(4) 合理配置 hash</h2><p>我们要保证，改过的文件需要更新 hash 值，而没改过的文件依然保持原本的 hash 值，这样才能保证在上线后，浏览器访问时没有改变的文件会命中缓存，从而达到性能优化的目的<br>在 webpack.base.js 中配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.base.js</span></span><br><span class="line"></span><br><span class="line"><span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../dist&#x27;</span>),</span><br><span class="line">    <span class="comment">//给js文件加上contenthash</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;js/chunk-[contenthash].js&#x27;</span>,</span><br><span class="line">    <span class="attr">clean</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang-defer-05</title>
      <link href="/2023/03/12/Golang/05defer/"/>
      <url>/2023/03/12/Golang/05defer/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note info flat"><p>defer 语句被用于预定对一个函数的调用。可以把这类被 defer 语句调用的函数称为延迟函数。</p><p>defer 作用：</p><p>● 释放占用的资源<br>● 捕捉处理异常<br>● 输出日志</p><p>结果</p><p>如果一个函数中有多个 defer 语句，它们会以 LIFO（后进先出）的顺序执行。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Demo</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;3&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">Demo()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure></div><div class="note warning flat"><p>运行时 panic 异常一旦被引发就会导致程序崩溃。</p><p>Go 语言提供了专用于“拦截”运行时 panic 的内建函数“recover”。它可以是当前的程序从运行时 panic 的状态中恢复并重新获得流程控制权。</p><p>注意：recover 只有在 defer 调用的函数中有效。</p><p>示例代码</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Demo</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">//定义10个元素的数组</span></span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">10</span>]<span class="type">int</span></span><br><span class="line"><span class="comment">//错误拦截要在产生错误前设置</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//设置recover拦截错误信息</span></span><br><span class="line">err := <span class="built_in">recover</span>()</span><br><span class="line"><span class="comment">//产生panic异常  打印错误信息</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">//根据函数参数为数组元素赋值</span></span><br><span class="line"><span class="comment">//如果i的值超过数组下标 会报错误：数组下标越界</span></span><br><span class="line">arr[i] = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">Demo(<span class="number">10</span>)</span><br><span class="line"><span class="comment">//产生错误后 程序继续</span></span><br><span class="line">fmt.Println(<span class="string">&quot;程序继续执行...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果程序没有异常，不会打印错误信息。</p></div>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue的生命周期</title>
      <link href="/2023/03/11/Vue/Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2023/03/11/Vue/Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note info flat"><p>今天来复习一下 Vue 中的每个生命周期分别都是什么以及都有什么用</p></div><div class="note primary flat"><h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p><img src="https://cn.vuejs.org/assets/lifecycle.16e4c08e.png"></p><h2 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h2><div class="note default flat"><p>初始化一个空的 Vue 实例,data、methods 等尚未被初始化，无法调用</p></div><h2 id="created"><a href="#created" class="headerlink" title="created"></a>created</h2><div class="note default flat"><p>Vue 实例初始化完成,data、methods 都已初始化完成，可调用<br>但尚未开始渲染模板</p></div><h2 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h2><div class="note default flat"><p>编译模板，调用 render 函数生成 vdom，但还没有开始渲染 DOM</p></div><h2 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h2><div class="note default flat"><p>渲染 DOM 完成，页面更新。组件创建完成，开始进入运行阶段</p></div><h2 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h2><div class="note default flat"><p>在数据发生改变后，DOM 被更新之前调用。这里适合在现有 DOM 将要被更新之前访问它，比如移出手动添加的事件监听器</p></div><h2 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h2><div class="note default flat"><p>在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用。<br><strong>注意：尽量不要在 updated 中继续修改数据，否则可能发触发死循环</strong></p></div><h2 id="onActivated"><a href="#onActivated" class="headerlink" title="onActivated"></a>onActivated</h2><div class="note default flat"><p>被 keep-alive 缓存的组件激活时调用</p></div><h2 id="onDeactivated"><a href="#onDeactivated" class="headerlink" title="onDeactivated"></a>onDeactivated</h2><div class="note default flat"><p>被 keep-alive 缓存的组件停用时调用</p></div><h2 id="beforeUnmount"><a href="#beforeUnmount" class="headerlink" title="beforeUnmount"></a>beforeUnmount</h2><div class="note default flat"><p>组件进入销毁阶段。<br>卸载组件实例后调用，在这个阶段，实例仍然是完全正常的。<br>移出、解绑一些全局事件、自定义事件，可以在此时操作</p></div><h2 id="unmounted"><a href="#unmounted" class="headerlink" title="unmounted"></a>unmounted</h2><div class="note default flat"><p>卸载组件实例后调用。调用此钩子时，组件实例的所有指令都被解除绑定，所有事件侦听器都被移出，所有子组件实例被卸载</p></div><h2 id="如何正确的操作-DOM"><a href="#如何正确的操作-DOM" class="headerlink" title="如何正确的操作 DOM"></a>如何正确的操作 DOM</h2><div class="note warning flat"><p>mounted 和 updated 都不会保证所有子组件都挂载完成，如果想等待所有视图都渲染完成，需要使用$nextTick</p><figure class="highlight javascript"><figcaption><span>Vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.$nextTick(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//仅在整个视图都被渲染之后才会运行的代码</span></span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang-函数-04</title>
      <link href="/2023/03/11/Golang/04%E5%87%BD%E6%95%B0/"/>
      <url>/2023/03/11/Golang/04%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><div class="note info flat"><p>golang 的函数可以返回多个值</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">string</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a, b := swap(<span class="string">&quot;Mahesh&quot;</span>, <span class="string">&quot;Kumar&quot;</span>)</span><br><span class="line">   fmt.Println(a, b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Kumar Mahesh</span></span><br></pre></td></tr></table></figure></div><h2 id="init-函数与-import"><a href="#init-函数与-import" class="headerlink" title="init 函数与 import"></a>init 函数与 import</h2><div class="note primary flat"><p>首先我们看一个例子：<strong>init 函数</strong>：<br>init 函数可在 package main 中，可在其他 package 中，可在同一个 package 中出现多次。<br><strong>main 函数</strong><br>main 函数只能在 package main 中。</p><p><strong>执行顺序</strong><br>golang 里面有两个保留的函数：init 函数（能够应用于所有的 package）和 main 函数（只能应用于 package main）。这两个函数在定义时不能有任何的参数和返回值。<br>虽然一个 package 里面可以写任意多个 init 函数，但这无论是对于可读性还是以后的可维护性来说，我们都强烈建议用户在一个 package 中每个文件只写一个 init 函数。</p><p>go 程序会自动调用 init()和 main()，所以你不需要在任何地方调用这两个函数。每个 package 中的 init 函数都是可选的，但 package main 就必须包含一个 main 函数。<br>程序的初始化和执行都起始于 main 包。</p><p>如果 main 包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，那么它只会被导入一次（例如很多包可能都会用到 fmt 包，但它只会被导入一次，因为没有必要导入多次）。<br>当一个包被导入时，如果该包还导入了其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行 init 函数（如果有的话），依次类推。</p><p>等所有被导入的包都加载完毕了，就会开始对 main 包中的包级常量和变量进行初始化，然后执行 main 包中的 init 函数（如果存在的话），最后执行 main 函数。下图详细地解释了整个执行过程：<br><img src="/img/31-init.png"></p></div><div class="note info flat"><p><mark class="hl-label pink">首先来看一个例子</mark><br><strong>代码结构</strong><br><img src="/img/32-init.png"><br><mark class="hl-label orange">Lib1.go</mark> </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> InitLib1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;lib1&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><mark class="hl-label orange">Lib2.go</mark> </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> InitLib2</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;lib2&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><mark class="hl-label orange">main.go</mark> </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    _ <span class="string">&quot;GolangTraining/InitLib1&quot;</span></span><br><span class="line">    _ <span class="string">&quot;GolangTraining/InitLib2&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;libmain init&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;libmian main&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代码输出</span></span><br><span class="line"><span class="comment">//lib1</span></span><br><span class="line"><span class="comment">// lib2</span></span><br><span class="line"><span class="comment">// libmain init</span></span><br><span class="line"><span class="comment">// libmian main</span></span><br></pre></td></tr></table></figure><p><strong>输出的顺序与我们上面图给出的顺序是一致的</strong></p><div class="note warning flat"><p>“_“引包无法通过包名来调用包中的导出函数，而是只是为了简单的调用其 init()函数。<br>“.”引包可以省略包名，不推荐使用</p></div><mark class="hl-label red">接下来我们改动一个地方,Lib1包导入Lib2，main包不管</mark> <div class="note danger flat"><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> InitLib1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    _ <span class="string">&quot;GolangTraining/InitLib2&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;lib1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//再执行main.go</span></span><br><span class="line"><span class="comment">//代码输出如下</span></span><br><span class="line"><span class="comment">// lib2</span></span><br><span class="line"><span class="comment">// lib1</span></span><br><span class="line"><span class="comment">// libmain init</span></span><br><span class="line"><span class="comment">// libmian main</span></span><br></pre></td></tr></table></figure><div class="note success flat"><p><strong>main 包以及 Lib1 包都导入了 Lib2，但是只出现一次，并且最先输出</strong></p><p><strong>说明如果一个包会被多个包同时导入，那么它只会被导入一次，而先输出 lib2 是因为 main 包中导入 Lib1 时，Lib1 又导入了 Lib2，会首先初始化 Lib2 包的东西</strong></p></div></div></div><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><div class="note primary flat"><h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><p>值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</p><p>默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。</p><p><mark class="hl-label default">以下定义了swap()函数：</mark> </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义相互交换值的函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">var</span> temp <span class="type">int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   temp = x <span class="comment">/* 保存 x 的值 */</span></span><br><span class="line">   x = y    <span class="comment">/* 将 y 值赋给 x */</span></span><br><span class="line">   y = temp <span class="comment">/* 将 temp 值赋给 y*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><mark class="hl-label default">接下来，让我们用值传递的方式调用swap()函数</mark> </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">100</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">int</span> = <span class="number">200</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换前 a 的值为 : %d\n&quot;</span>, a )</span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换前 b 的值为 : %d\n&quot;</span>, b )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 通过调用函数来交换值 */</span></span><br><span class="line">   swap(a, b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换后 a 的值 : %d\n&quot;</span>, a )</span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换后 b 的值 : %d\n&quot;</span>, b )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义相互交换值的函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">var</span> temp <span class="type">int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   temp = x <span class="comment">/* 保存 x 的值 */</span></span><br><span class="line">   x = y    <span class="comment">/* 将 y 值赋给 x */</span></span><br><span class="line">   y = temp <span class="comment">/* 将 temp 值赋给 y*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">// 交换前 a 的值为 : 100</span></span><br><span class="line"><span class="comment">// 交换前 b 的值为 : 200</span></span><br><span class="line"><span class="comment">// 交换后 a 的值 : 100</span></span><br><span class="line"><span class="comment">// 交换后 b 的值 : 200</span></span><br></pre></td></tr></table></figure><h3 id="引用传递-指针传递"><a href="#引用传递-指针传递" class="headerlink" title="引用传递(指针传递)"></a>引用传递(指针传递)</h3><p><mark class="hl-label default">指针</mark><br>Go 语言中指针是很容易学习的，Go 语言中使用指针可以更简单的执行一些任务。<br>接下来让我们来一步步学习 Go 语言指针。<br>我们都知道，变量是一种使用方便的占位符，用于引用计算机内存地址。<br>Go 语言的取地址符是 &amp;，放到一个变量前使用就会返回相应变量的内存地址。<br>以下实例演示了变量在内存中地址：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;变量的地址: %x\n&quot;</span>, &amp;a  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//变量的地址: 20818a220</span></span><br></pre></td></tr></table></figure><p><strong>现在我们已经了解了什么是内存地址和如何去访问它。接下来我们将具体介绍指针。</strong><br><strong>引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</strong><br><strong>引用传递指针参数传递到函数内，以下是交换函数 swap() 使用了引用传递：</strong><br><mark class="hl-label default">重新定义下swap()函数</mark> </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义交换值函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x *<span class="type">int</span>, y *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> temp <span class="type">int</span></span><br><span class="line">   temp = *x    <span class="comment">/* 保持 x 地址上的值 */</span></span><br><span class="line">   *x = *y      <span class="comment">/* 将 y 值赋给 x */</span></span><br><span class="line">   *y = temp    <span class="comment">/* 将 temp 值赋给 y */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><mark class="hl-label default">使用引用传递调用swap()函数</mark> </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">100</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">int</span>= <span class="number">200</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换前，a 的值 : %d\n&quot;</span>, a )</span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换前，b 的值 : %d\n&quot;</span>, b )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 调用 swap() 函数</span></span><br><span class="line"><span class="comment">   * &amp;a 指向 a 指针，a 变量的地址</span></span><br><span class="line"><span class="comment">   * &amp;b 指向 b 指针，b 变量的地址</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   swap(&amp;a, &amp;b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换后，a 的值 : %d\n&quot;</span>, a )</span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换后，b 的值 : %d\n&quot;</span>, b )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x *<span class="type">int</span>, y *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> temp <span class="type">int</span></span><br><span class="line">   temp = *x    <span class="comment">/* 保存 x 地址上的值 */</span></span><br><span class="line">   *x = *y      <span class="comment">/* 将 y 值赋给 x */</span></span><br><span class="line">   *y = temp    <span class="comment">/* 将 temp 值赋给 y */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以上代码执行结果为：</span></span><br><span class="line"><span class="comment">// 交换前，a 的值 : 100</span></span><br><span class="line"><span class="comment">// 交换前，b 的值 : 200</span></span><br><span class="line"><span class="comment">// 交换后，a 的值 : 200</span></span><br><span class="line"><span class="comment">// 交换后，b 的值 : 100</span></span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang常量-03</title>
      <link href="/2023/03/11/Golang/03%E5%B8%B8%E9%87%8F/"/>
      <url>/2023/03/11/Golang/03%E5%B8%B8%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><div class="note info flat"><p>常量是一个简单值的标识符，在程序运行时，不会被修改的量<br>常量中的数据类型只可以是布尔值、数字型(整数型、浮点型和复数)和字符串型</p></div><h2 id="常量的定义格式"><a href="#常量的定义格式" class="headerlink" title="常量的定义格式"></a>常量的定义格式</h2><div class="note primary flat"><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> identifier [<span class="keyword">type</span>] = value</span><br></pre></td></tr></table></figure><p><strong>你可以省略类型说明符[type]，因为编译器可以根据变量的值来推断其类型</strong></p><h3 id="显式类型定义"><a href="#显式类型定义" class="headerlink" title="显式类型定义:"></a>显式类型定义:</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> b <span class="type">string</span> = <span class="string">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure><h3 id="隐式类型定义"><a href="#隐式类型定义" class="headerlink" title="隐式类型定义"></a>隐式类型定义</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> b = <span class="string">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure></div><div class="note info flat"><p>常量还能用来枚举</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">  Unknow = <span class="number">0</span></span><br><span class="line">  Female = <span class="number">1</span></span><br><span class="line">  Male = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//数字0、1、2分别代表未知性别、男性、女性</span></span><br></pre></td></tr></table></figure></div><div class="note info flat"><p>常量还可以用 len(),cap(),unsafe.Sizeof()常量计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;unsafe&quot;</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="string">&quot;abc&quot;</span></span><br><span class="line">    b = <span class="built_in">len</span>(a)</span><br><span class="line">    c = unsafe.Sizeof(a)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">println</span>(a, b, c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果为：abc,3,16</span></span><br></pre></td></tr></table></figure><p><strong>注意:unsafe.Sizeof(a)输出的结果是 16。</strong><br><strong>字符串类型在 go 里是个结构,包含指向底层数组的指针和长度,这两部分每部分都是 8 个字节，所以字符串类型大小为 16 个字节。</strong></p></div><h2 id="优雅的常量-iota"><a href="#优雅的常量-iota" class="headerlink" title="优雅的常量 iota"></a>优雅的常量 iota</h2><div class="note primary flat"><p>iota，特殊常量，可以认为是一个可以被编译器修改的常量。</p><p>iota 在 const 关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。</p><p>iota 可以被用作枚举值：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span></span><br><span class="line">    b = <span class="literal">iota</span></span><br><span class="line">    c = <span class="literal">iota</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a&#x3D;0, b&#x3D;1, c&#x3D;2 可以简写为如下形式：</strong></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span></span><br><span class="line">    b</span><br><span class="line">    c</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><h3 id="iota-用法"><a href="#iota-用法" class="headerlink" title="iota 用法"></a>iota 用法</h3><div class="note info flat"><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">            a = <span class="literal">iota</span>   <span class="comment">//0</span></span><br><span class="line">            b          <span class="comment">//1</span></span><br><span class="line">            c          <span class="comment">//2</span></span><br><span class="line">            d = <span class="string">&quot;ha&quot;</span>   <span class="comment">//独立值，iota += 1</span></span><br><span class="line">            e          <span class="comment">//&quot;ha&quot;   iota += 1</span></span><br><span class="line">            f = <span class="number">100</span>    <span class="comment">//iota +=1</span></span><br><span class="line">            g          <span class="comment">//100  iota +=1</span></span><br><span class="line">            h = <span class="literal">iota</span>   <span class="comment">//7,恢复计数</span></span><br><span class="line">            i          <span class="comment">//8</span></span><br><span class="line">    )</span><br><span class="line">    fmt.Println(a,b,c,d,e,f,g,h,i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果为(0 1 2 ha ha 100 100 7 8)</span></span><br></pre></td></tr></table></figure></div><div class="note info flat"><p>再看个有趣的的 iota 实例:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    i=<span class="number">1</span>&lt;&lt;<span class="literal">iota</span></span><br><span class="line">    j=<span class="number">3</span>&lt;&lt;<span class="literal">iota</span></span><br><span class="line">    k</span><br><span class="line">    l</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;i=&quot;</span>,i)</span><br><span class="line">    fmt.Println(<span class="string">&quot;j=&quot;</span>,j)</span><br><span class="line">    fmt.Println(<span class="string">&quot;k=&quot;</span>,k)</span><br><span class="line">    fmt.Println(<span class="string">&quot;l=&quot;</span>,l)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// i=1</span></span><br><span class="line"><span class="comment">// j=6</span></span><br><span class="line"><span class="comment">// k=12</span></span><br><span class="line"><span class="comment">// l=24</span></span><br></pre></td></tr></table></figure><p><strong>iota 表示从 0 开始自动加 1，所以 i&#x3D;1&lt;&lt;0, j&#x3D;3&lt;&lt;1（&lt;&lt; 表示左移的意思），即：i&#x3D;1, j&#x3D;6，这没问题，关键在 k 和 l，从输出结果看 k&#x3D;3&lt;&lt;2，l&#x3D;3&lt;&lt;3。</strong></p><p>简单表述:</p><ul><li>i&#x3D;1：左移 0 位，不变仍为 1。</li><li>j&#x3D;3：左移 1 位，变为二进制 110，即 6。</li><li>k&#x3D;3：左移 2 位，变为二进制 1100，即 12。</li><li>l&#x3D;3：左移 3 位，变为二进制 11000，即 24。</li></ul><p><strong>注:&lt;&lt;n&#x3D;&#x3D;*(2^n)。</strong></p></div>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang的变量声明-02</title>
      <link href="/2023/03/10/Golang/02%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E/"/>
      <url>/2023/03/10/Golang/02%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note info flat"><p>这一篇讲一下变量的声明</p></div><h2 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h2><div class="note primary flat"><p>声明变量的一般形式是使用 var 关键字</p></div><h2 id="变量声明的几种方式"><a href="#变量声明的几种方式" class="headerlink" title="变量声明的几种方式"></a>变量声明的几种方式</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//第一种 使用默认值</span></span><br><span class="line">        <span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;a = %d\n&quot;</span>, a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种</span></span><br><span class="line">        <span class="keyword">var</span> b <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;b = %d\n&quot;</span>, b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三种 省略后面的数据类型,自动匹配类型</span></span><br><span class="line">        <span class="keyword">var</span> c = <span class="number">20</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;c = %d\n&quot;</span>, c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第四种 省略var关键字</span></span><br><span class="line">        d := <span class="number">3.14</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;d = %f\n&quot;</span>, d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang开始之旅</title>
      <link href="/2023/03/10/Golang/First_Golang/"/>
      <url>/2023/03/10/Golang/First_Golang/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><div class="note info simple"><p>最近因为在学习 golang，所以在这里记录一下我的 golang 学习。<br>安装就不写了,golang 的安装很简单。分为以下两步:<br>1、找到安装包下载安装<br>2、配置环境变量</p></div><h2 id="First-Golang"><a href="#First-Golang" class="headerlink" title="First_Golang"></a>First_Golang</h2><div class="note primary flat"><p>第一篇关于 golang 的博客，当然是从”<strong>Hello World</strong>“开始了</p></div><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//package main定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//import &quot;fmt&quot;告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数。</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//func main()是程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello go!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info warning flat"><p><strong>注意：这里面 go 语言的语法，定义函数的时候，”{“ 必须和函数名在同一行，不能另起一行。</strong></p></div><h2 id="终端运行"><a href="#终端运行" class="headerlink" title="终端运行"></a>终端运行</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 方式一 --&gt;</span><br><span class="line">go run 文件名.go</span><br><span class="line"></span><br><span class="line">&lt;!-- 方法二 --&gt;</span><br><span class="line">go build 文件名.go //编译代码</span><br><span class="line">./main            //运行可执行文件</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用defer优化首屏白屏时间</title>
      <link href="/2023/03/10/Vue/%E4%BD%BF%E7%94%A8defer%E4%BC%98%E5%8C%96%E7%99%BD%E5%B1%8F%E6%97%B6%E9%97%B4/"/>
      <url>/2023/03/10/Vue/%E4%BD%BF%E7%94%A8defer%E4%BC%98%E5%8C%96%E7%99%BD%E5%B1%8F%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note primary flat"><p>本次演示为 Vue3 语法，使用情况得分具体情况具体分析，下面来介绍一种情况导致首屏白屏时间过久的例子。超级好用</p></div><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><div class="note info flat"><p>我们知道，Vue 框架是 spa(单页面)应用，<mark class="hl-label green">优点</mark> 很多，比如切换页面快、用户体验比较好、后期好维护<br>当然<mark class="hl-label red">缺点</mark> 也有，因为是单页面应用，所以不利于 SEO 优化(可以借助 SSR 来优化 SEO)，另一个重要的就是首屏加载时间长了。因为 SPA 是一开始就把所有的资源加载好，所以比起 MPA(多页面)，首屏的加载时间要更久。<br><strong>这时候如果首屏加载时间过久将会非常影响用户体验</strong></p></div><h2 id="Vue-代码"><a href="#Vue-代码" class="headerlink" title="Vue 代码"></a>Vue 代码</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">HeavyCom</span> <span class="keyword">from</span> <span class="string">&#x27;./heavy.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; useDefer &#125; <span class="keyword">from</span> <span class="string">&#x27;../utils/useDefer&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> defer = <span class="title function_">useDefer</span>()</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">defineProps</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">msg</span>: <span class="title class_">String</span>,</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;contain&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;n, i in 100&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;i&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">HeavyCom</span> <span class="attr">:i</span>=<span class="string">&quot;i&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;defer(n)&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.contain</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">flex-wrap</span>: wrap;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="JavaScript-代码"><a href="#JavaScript-代码" class="headerlink" title="JavaScript 代码"></a>JavaScript 代码</h2><figure class="highlight javascript"><figcaption><span>useDefer.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useDefer</span>(<span class="params">maxFrameCount = <span class="number">1000</span></span>) &#123;</span><br><span class="line">  <span class="comment">//渲染设置初始值</span></span><br><span class="line">  <span class="keyword">const</span> frameCount = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">refreshFrameCount</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">//渲染帧函数，跟随浏览器渲染</span></span><br><span class="line">    <span class="title function_">requestAnimationFrame</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      frameCount.<span class="property">value</span>++;</span><br><span class="line">      <span class="keyword">if</span> (frameCount.<span class="property">value</span> &lt; maxFrameCount) &#123;</span><br><span class="line">        <span class="title function_">refreshFrameCount</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">refreshFrameCount</span>();</span><br><span class="line">  <span class="comment">//返回一个布尔值</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">showInFrameCount</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> frameCount.<span class="property">value</span> &gt;= showInFrameCount;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考视频"><a href="#参考视频" class="headerlink" title="参考视频"></a>参考视频</h2><div class="note pink icon-padding flat"><i class="note-icon fas fa-fan"></i><p>相关链接: <a href="https://v.douyin.com/SmxBATa/">https://v.douyin.com/SmxBATa/</a></p></div>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是BFC，怎么触发</title>
      <link href="/2023/03/09/CSS/BFC/"/>
      <url>/2023/03/09/CSS/BFC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note warning simple"><p>什么是BFC？</p></div><div class="note default no-icon flat"><p>BFC，英文全称 <strong>block formatting context(块级格式化上下文)</strong></p><p>有时候我们在进行布局的时候会发生一些意想不到的情况，这时候就需要我们去触发BFC去解决下面这一些问题</p><ul><li>父元素高度塌陷</li><li>父元素不受子元素margin影响</li><li>外边距重叠</li><li>不受兄弟元素float影响</li></ul></div><h2 id="为什么触发BFC能够解决这些问题？"><a href="#为什么触发BFC能够解决这些问题？" class="headerlink" title="为什么触发BFC能够解决这些问题？"></a>为什么触发BFC能够解决这些问题？</h2><div class="note primary simple"><p>因为触发了BFC，它就会给我们这个元素给它进行独立渲染，开辟出一块空间，这样子一来，就不会影响到这个元素它外部元素的一些布局情况</p></div><h2 id="如何去触发BFC"><a href="#如何去触发BFC" class="headerlink" title="如何去触发BFC"></a>如何去触发BFC</h2><div class="note primary simple"><p>根元素(html),就是一块独立渲染的空间</p><ol><li>浮动元素(元素的float不是none)</li><li>绝对定位元素(元素的position为absolution或fixed)</li><li>display不为none</li><li>overflow不为visible的块元素</li><li>contain值为layout、context或paint的元素</li><li>多列容器(元素的column-count或column-width不为auto，包括column-count为1)</li></ol></div><div class="note success simple"><p>当然，触发BFC的方式很多，不过我们平常使用<mark class="hl-label green">第四种</mark> 方法，或者<mark class="hl-label green">第三种</mark> 方法比较多，影响比较小，<mark class="hl-label orange">不建议用float浮动</mark> ，因为用了float浮动会造成元素脱离标准文档流，导致高度塌陷。要解决float浮动的后遗症需要加入下面代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//使用伪类清除高度塌陷问题</span><br><span class="line">元素<span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    context:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">clear</span>:both</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防抖与节流</title>
      <link href="/2023/03/09/JavaScript/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/"/>
      <url>/2023/03/09/JavaScript/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><div class="note warning simple"><p>在了解防抖和节流函数之前，首先我们要先了解什么是闭包，因为防抖节流函数都是在闭包的基础上进行的。</p></div><div class="note default no-icon flat"><p><strong>闭包是指有权访问另一个函数作用域中变量的函数</strong>，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。</p><p>闭包有两个常用的用途：</p><ul><li><p>创建私有变量</p></li><li><p>保留变量对象</p></li></ul><p><strong>缺点就是不会启动 JS 中的垃圾自动回收机制，会造成内存泄漏，需要手动清除</strong></p></div><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><div class="note primary simple"><p>函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, wait</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果此时存在定时器的话，就取消之前的定时器重新计时</span></span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置定时器，使事件间隔指定事件后执行</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><div class="note primary simple"><p>函数节流是指一个单位事件，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数等一些高频率触发的事件监听上，通过事件节流来降低事件调用的频率。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn,delay</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> curTime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="variable language_">this</span></span><br><span class="line">        <span class="keyword">let</span> args = <span class="variable language_">arguments</span></span><br><span class="line">        <span class="keyword">let</span> now <span class="title class_">Time</span> = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果两次时间间隔超过了指定时间，则执行函数。</span></span><br><span class="line">        <span class="keyword">if</span>(nowTime - curTime &gt;= delay)&#123;</span><br><span class="line">            curTime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">            <span class="keyword">return</span> fn.<span class="title function_">apply</span>(context, args)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2023/03/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/03/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="不知道要写些什么"><a href="#不知道要写些什么" class="headerlink" title="不知道要写些什么"></a>不知道要写些什么</h2><div class="note icon-padding flat"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>2021 年快到了….</p></div><div class="note pink icon-padding flat"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding flat"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding flat"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding flat"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><div class="note success simple"><p>最后来个十万个为什么</p></div><p>为什么鱼香肉丝没有鱼 <span class="hide-inline"><button type="button" class="hide-button" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">说得我的钱包就有钱一样</span></span></p><p>千万不要和风打架 <span class="hide-inline"><button type="button" class="hide-button" style="background-color: #FF7242;color: #fff">下一句  </button><span class="hide-content">就算你武功高，风没伤到你，你伤风了，也会感冒</span></span></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
